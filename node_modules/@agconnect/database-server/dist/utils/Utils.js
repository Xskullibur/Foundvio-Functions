"use strict";
/**
 * Copyright (c) Huawei Technologies Co., Ltd. 2020-2020. All rights reserved.
 */
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Utils = void 0;
var FieldType_1 = require("./FieldType");
var AGConnectCloudDBException_1 = require("../exception/AGConnectCloudDBException");
var CloudDBErrorCode_1 = require("../exception/CloudDBErrorCode");
var DataModelHelper_1 = require("./DataModelHelper");
/**
 * the utils class.
 *
 * @author fangpeiwen [fangpeiwen@huawei.com]
 * @since 2020-12-02
 */
var Utils = /** @class */ (function () {
    function Utils() {
    }
    /**
     * This method is used to check whether the input value is Array.
     *
     * @param value the value that need to check.
     * @returns whether the input is a array.
     */
    Utils.isArray = function (value) {
        if (typeof Array.isArray === 'function') {
            return Array.isArray(value);
        }
        else {
            return Object.prototype.toString.call(value) === '[object Array]';
        }
    };
    /**
     * This method is used to check whether the input value is null or undefined.
     *
     * @param value the value that need to check.
     * @returns whether the input is a null or undefined.
     */
    Utils.isNullOrUndefined = function (value) {
        return value === undefined || value === null;
    };
    /**
     * This method is used to check whether the input value is type of object.
     *
     * @param value the value that need to check.
     * @returns whether the input is type of object.
     */
    Utils.isNotNullObject = function (value) {
        return value !== null ? typeof value === 'object' : false;
    };
    /**
     * This method is used to serialize objects.
     *
     * @param objects a list of objects.
     * @returns a list of serialized objects.
     */
    Utils.serializeObjects = function (objects) {
        var _this = this;
        var formatedData = [];
        objects.forEach(function (element) {
            var object = _this.serializeObject(element);
            formatedData.push(object);
        });
        return formatedData;
    };
    Utils.serializeDate = function (date) {
        if (!(date instanceof Date)) {
            return date;
        }
        var utcDateString = date.toISOString();
        var result = utcDateString.replace('T', ' ').replace('.', ' ').replace('Z', '');
        if (!this.DATE_REG_EXP.test(result)) {
            console.warn('The date string inputed is invalid: ', result);
            throw new AGConnectCloudDBException_1.AGConnectCloudDBException(CloudDBErrorCode_1.CloudDBErrorCode.DATE_STRING_INVALID);
        }
        return result;
    };
    /**
     * This method is used to deserialize objects.
     *
     * @param objects a list of objects.
     * @param fieldTypeMap a map of field name and filed type.
     * @param targetClass the class that json string deserializes to.
     * @returns a list of deserialized objects.
     */
    Utils.deserializeObjects = function (objects, fieldTypeMap, targetClass) {
        var formatedData = [];
        objects.forEach(function (element) {
            var e_1, _a;
            var object = new targetClass();
            try {
                for (var _b = __values(fieldTypeMap.keys()), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var key = _c.value;
                    if (element[key] == null || object.getEncryptedFieldList().includes(key)) {
                        object[key] = undefined;
                        continue;
                    }
                    var fieldType = fieldTypeMap.get(key);
                    if (fieldType === FieldType_1.FieldType.Date) {
                        object[key] = Utils.deserializeDate(element[key]);
                        continue;
                    }
                    if (Utils.isFieldTypeNumber(fieldType)) {
                        object[key] = Utils.deserializeNumber(element[key]);
                        continue;
                    }
                    if (fieldType === FieldType_1.FieldType.ByteArray) {
                        object[key] = Utils.base64ToArrayBuffer(element[key]);
                        continue;
                    }
                    object[key] = element[key];
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            formatedData.push(object);
        });
        return formatedData;
    };
    Utils.arrayBufferToBase64 = function (arrayBuffer) {
        var buffer = Buffer.from(arrayBuffer);
        return buffer.toString('base64');
    };
    Utils.base64ToArrayBuffer = function (base64) {
        var myBuffer = Buffer.from(base64, 'base64');
        var int8View = new Uint8Array(myBuffer);
        return int8View.slice();
    };
    Utils.isFieldTypeNumber = function (fieldType) {
        if (!fieldType) {
            throw new AGConnectCloudDBException_1.AGConnectCloudDBException(CloudDBErrorCode_1.CloudDBErrorCode.PARAMETER_INVALID);
        }
        switch (fieldType) {
            case FieldType_1.FieldType.Byte:
            case FieldType_1.FieldType.Short:
            case FieldType_1.FieldType.Integer:
            // remaining case FieldType.Long
            case FieldType_1.FieldType.Float:
            case FieldType_1.FieldType.Double:
                return true;
            default:
                return false;
        }
    };
    Utils.deserializeNumber = function (data) {
        if (typeof data === 'string') {
            var res = Number(data).valueOf();
            return res;
        }
        return data;
    };
    Utils.deserializeDate = function (date) {
        if (!this.DATE_REG_EXP.test(date)) {
            console.warn('The date string from cloud is invalid: ', date);
            throw new AGConnectCloudDBException_1.AGConnectCloudDBException(CloudDBErrorCode_1.CloudDBErrorCode.DATE_STRING_INVALID);
        }
        var utcDateString = date.replace(' ', 'T').replace(' ', '.') + 'Z';
        return new Date(utcDateString);
    };
    /**
     * This method is used to serialize queryConditions.
     *
     * @param queryConditions the input query conditions.
     * @param fieldTypeMap a map of field name and filed type.
     * @returns the serialized queryConditions.
     */
    Utils.serializeQueryConditions = function (queryConditions, fieldTypeMap) {
        var _this = this;
        var formatedCondition = [];
        queryConditions.forEach(function (queryCondition) {
            var conditionCopy = {};
            Object.assign(conditionCopy, queryCondition);
            if (Utils.isPaginationType(queryCondition.conditionType)) {
                if (!Utils.isObjectValid(queryCondition.value)) {
                    console.warn(new AGConnectCloudDBException_1.AGConnectCloudDBException(CloudDBErrorCode_1.CloudDBErrorCode.OBJECT_IS_INVALID).message);
                    throw new AGConnectCloudDBException_1.AGConnectCloudDBException(CloudDBErrorCode_1.CloudDBErrorCode.OBJECT_IS_INVALID);
                }
                conditionCopy.value = _this.serializeObject(queryCondition.value);
                formatedCondition.push(conditionCopy);
                return;
            }
            if (fieldTypeMap.get(queryCondition.fieldName) === FieldType_1.FieldType.Date
                && queryCondition.conditionType === "In" /* IN */) {
                for (var i = 0; i < queryCondition.value.length; i++) {
                    conditionCopy.value[i] = Utils.serializeDate(queryCondition.value[i]);
                }
            }
            else {
                conditionCopy.value = Utils.serializeDate(queryCondition.value);
            }
            formatedCondition.push(conditionCopy);
        });
        return formatedCondition;
    };
    /**
     * This method is used to check whether the input fieldType is numeric type.
     *
     * @param fieldType the fieldType that needs to check.
     * @returns boolean value of the check result.
     */
    Utils.isNumericField = function (fieldType) {
        return fieldType === FieldType_1.FieldType.Double || fieldType === FieldType_1.FieldType.Byte || fieldType === FieldType_1.FieldType.Float
            || fieldType === FieldType_1.FieldType.Integer || fieldType === FieldType_1.FieldType.Long || fieldType === FieldType_1.FieldType.Short;
    };
    /**
     * This method is used to check whether the input class is valid.
     *
     * @param clazz the class that needs to check.
     * @throws throw an AGConnectCloudDBException if the class is invalid.
     */
    Utils.clazzCheck = function (clazz) {
        var obj = new clazz();
        if (!this.isObjectValid(obj)) {
            console.warn(new AGConnectCloudDBException_1.AGConnectCloudDBException(CloudDBErrorCode_1.CloudDBErrorCode.CLASS_INVALID).message);
            throw new AGConnectCloudDBException_1.AGConnectCloudDBException(CloudDBErrorCode_1.CloudDBErrorCode.CLASS_INVALID);
        }
    };
    /**
     * This method is used to check whether the input object is valid.
     *
     * @param object the object that needs to check.
     * @returns boolean value of the check result.
     */
    Utils.isObjectValid = function (object) {
        return (typeof object.getFieldTypeMap == 'function'
            && typeof object.getClassName == 'function'
            && typeof object.getPrimaryKeyList == 'function'
            && typeof object.getIndexList == 'function'
            && typeof object.getEncryptedFieldList == 'function');
    };
    Utils.serializeObject = function (element) {
        var e_2, _a;
        var object = {};
        var fieldTypeMap = element.getFieldTypeMap();
        var encryptedFieldList = element.getEncryptedFieldList();
        try {
            for (var _b = __values(Object.keys(element)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var key = _c.value;
                if (element[key] == null || encryptedFieldList.includes(key)) {
                    continue;
                }
                var fieldType = fieldTypeMap.get(key);
                if (Utils.isNumericField(fieldType) && !isFinite(element[key])) {
                    console.warn(new AGConnectCloudDBException_1.AGConnectCloudDBException(CloudDBErrorCode_1.CloudDBErrorCode.NUMBER_IS_INVALID).message);
                    throw new AGConnectCloudDBException_1.AGConnectCloudDBException(CloudDBErrorCode_1.CloudDBErrorCode.NUMBER_IS_INVALID);
                }
                if (fieldTypeMap.get(key) === FieldType_1.FieldType.Date) {
                    object[key] = Utils.serializeDate(element[key]);
                    continue;
                }
                if (fieldType === FieldType_1.FieldType.ByteArray) {
                    object[key] = Utils.arrayBufferToBase64(element[key]);
                    continue;
                }
                object[key] = element[key];
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return object;
    };
    /**
     * This method is used to check whether the input conditionType is aggregate type.
     *
     * @param conditionType the conditionType that needs to check.
     * @returns boolean value of the check result.
     */
    Utils.isAggregateType = function (conditionType) {
        var array = ["Average" /* AVG */, "Count" /* COUNT */, "Max" /* MAX */, "Min" /* MIN */,
            "Sum" /* SUM */];
        return array.includes(conditionType);
    };
    /**
     * This method is used to check whether the input conditionType is pagination type.
     *
     * @param conditionType the conditionType that needs to check.
     * @returns boolean value of the check result.
     */
    Utils.isPaginationType = function (conditionType) {
        var array = ["StartAt" /* START_AT */, "StartAfter" /* START_AFTER */, "EndAt" /* END_AT */,
            "EndBefore" /* END_BEFORE */];
        return array.includes(conditionType);
    };
    /**
     * This method is used to check whether the object list contains different schema
     * and whether the data size is too large.
     *
     * @param objectList the input objectList.
     */
    Utils.checkSchemaAndDataSize = function (objectList) {
        var _this = this;
        var className;
        objectList.forEach(function (element) {
            if (!Utils.isObjectValid(element)) {
                console.warn(new AGConnectCloudDBException_1.AGConnectCloudDBException(CloudDBErrorCode_1.CloudDBErrorCode.OBJECT_IS_INVALID).message);
                throw new AGConnectCloudDBException_1.AGConnectCloudDBException(CloudDBErrorCode_1.CloudDBErrorCode.OBJECT_IS_INVALID);
            }
            if (!DataModelHelper_1.DataModelHelper.validate(element)) {
                console.warn(new AGConnectCloudDBException_1.AGConnectCloudDBException(CloudDBErrorCode_1.CloudDBErrorCode.ERROR_CODE_DATA_INVALID).message);
                throw new AGConnectCloudDBException_1.AGConnectCloudDBException(CloudDBErrorCode_1.CloudDBErrorCode.ERROR_CODE_DATA_INVALID);
            }
            if (className == null) {
                className = element.getClassName();
            }
            if (className != element.getClassName()) {
                console.warn(new AGConnectCloudDBException_1.AGConnectCloudDBException(CloudDBErrorCode_1.CloudDBErrorCode.ONLY_SUPPORT_ONE_SCHEMA).message);
                throw new AGConnectCloudDBException_1.AGConnectCloudDBException(CloudDBErrorCode_1.CloudDBErrorCode.ONLY_SUPPORT_ONE_SCHEMA);
            }
            _this.checkIllegalCharacter(element);
            var objectListSize = DataModelHelper_1.DataModelHelper.calculateObject(element);
            if (objectListSize > Utils.MAX_OBJECT_CAPACITY) {
                console.warn(new AGConnectCloudDBException_1.AGConnectCloudDBException(CloudDBErrorCode_1.CloudDBErrorCode.DATA_SIZE_OVERFLOW).message);
                throw new AGConnectCloudDBException_1.AGConnectCloudDBException(CloudDBErrorCode_1.CloudDBErrorCode.DATA_SIZE_OVERFLOW);
            }
        });
    };
    /**
     * This method is used to check whether the object contains illegal character.
     *
     * @param object the object needs to be checked.
     */
    Utils.checkIllegalCharacter = function (object) {
        var e_3, _a;
        var fieldTypeMap = object.getFieldTypeMap();
        try {
            for (var _b = __values(fieldTypeMap.keys()), _c = _b.next(); !_c.done; _c = _b.next()) {
                var key = _c.value;
                if (fieldTypeMap.get(key) == 'String' || fieldTypeMap.get(key) == 'Text') {
                    var value = object[key];
                    if (value == null) {
                        continue;
                    }
                    if (value.indexOf('\0') !== -1) {
                        console.warn(new AGConnectCloudDBException_1.AGConnectCloudDBException(CloudDBErrorCode_1.CloudDBErrorCode.INPUT_CONTAIN_ILLEGAL_CHARACTER).message);
                        throw new AGConnectCloudDBException_1.AGConnectCloudDBException(CloudDBErrorCode_1.CloudDBErrorCode.INPUT_CONTAIN_ILLEGAL_CHARACTER);
                    }
                }
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_3) throw e_3.error; }
        }
    };
    Utils.DATE_REG_EXP = /^[1-9]\d{3}-\d{2}-\d{2}\s\d{2}:\d{2}:\d{2}\s\d{3}/;
    Utils.MAX_OBJECT_CAPACITY = 2 * 1024 * 1024;
    return Utils;
}());
exports.Utils = Utils;
